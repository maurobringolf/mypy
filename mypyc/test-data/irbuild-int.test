[case testIntNeq]
def f(x: int, y: int) -> bool:
    return x != y
[out]
def f(x, y):
    x, y :: int
    r0 :: bool
    r1 :: native_int
    r2, r3, r4, r5 :: bit
L0:
    r1 = x & 1
    r2 = r1 == 0
    if r2 goto L1 else goto L2 :: bool
L1:
    r3 = x != y
    r0 = r3
    goto L3
L2:
    r4 = CPyTagged_IsEq_(x, y)
    r5 = r4 ^ 1
    r0 = r5
L3:
    return r0

[case testShortIntComparisons]
def f(x: int) -> int:
    if x == 3:
        return 1
    elif x != 4:
        return 2
    elif 5 == x:
        return 3
    elif 6 != x:
        return 4
    elif x < 4:
        return 5
    return 6
[out]
def f(x):
    x :: int
    r0, r1, r2, r3 :: bit
    r4 :: native_int
    r5, r6, r7 :: bit
L0:
    r0 = x == 6
    if r0 goto L1 else goto L2 :: bool
L1:
    return 2
L2:
    r1 = x != 8
    if r1 goto L3 else goto L4 :: bool
L3:
    return 4
L4:
    r2 = 10 == x
    if r2 goto L5 else goto L6 :: bool
L5:
    return 6
L6:
    r3 = 12 != x
    if r3 goto L7 else goto L8 :: bool
L7:
    return 8
L8:
    r4 = x & 1
    r5 = r4 != 0
    if r5 goto L9 else goto L10 :: bool
L9:
    r6 = CPyTagged_IsLt_(x, 8)
    if r6 goto L11 else goto L12 :: bool
L10:
    r7 = x < 8 :: signed
    if r7 goto L11 else goto L12 :: bool
L11:
    return 10
L12:
L13:
L14:
L15:
L16:
    return 12

[case test1_IntOpt]
def f(x: int) -> int:
	x = 1
	return x
[out]
def f(x):
    x :: int32
L0:
    x = 1
    return x

[case test2_IntOpt]
def f(x: int) -> int:
	x = 1 + 3
	return x
[out]
def f(x):
    x, r0 :: int32
L0:
    r0 = 1 + 3
    x = r0
    return x

[case test3_IntOpt]
def f() -> int:
	max32plus1 = 4294967296
	max32 = 4294967295
	min32 = -4294967296
	min32minus1 = -4294967297
	return 1
[out]
def f():
    max32plus1 :: int
    max32 :: int32
    r0, min32, r1, min32minus1 :: int
    r2 :: int32
L0:
    max32plus1 = 8589934592
    max32 = 4294967295
    r0 = CPyTagged_Negate(8589934592)
    r2 = unbox(int32, r0)
    min32 = r2
    r1 = CPyTagged_Negate(8589934594)
    min32minus1 = r1
    return 1
